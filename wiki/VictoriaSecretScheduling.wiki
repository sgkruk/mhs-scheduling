#Typical scheduling of employees in a retail store

= Introduction =

The paradigmatic retail store has full time, part time employees, managers and worker bees. It has to staff the floor with varying number of people of varying experience.  


= Note on implementation =

We discuss rostering: the scheduling of people.  We decided to view this abstractly, as the establishment of a relation between employees and timeslots.  For example the named couple work(serge, Monday-at-8) means employee Serge works Monday at 8.  Note that there is no duration. We have decomposed the time to schedule into the smallest scheduling unit.  

This does not force an implementation.  The set of all couples name(e,h) form the relation and could be viewed as: 
  * a bipartite graph with employees on one side, timeslots on the other and an edge iff the employee works at that time
  * a multi-level network with employees on one level, months on the second, weeks of the month on the third, days ...
  * a binary matrix indexed by employee and timeslots with a 1 of scheduled, 0 otherwise
  * a record per employee with a list of timeslots when he/she works

The point is that we are not committed, at this point to a specific implementation. We leave the options open but want an abstract concept of what a roster is.  The relation name(e,h) seems to work (for now).

= Sets of resources and timeslots = 

We decided that the data should be separated from the models as much as possible. Two sets, at a minimum, are required to establish the relation. and sets are ordered.
{{{
set E; /* All employees */
set T; /* All timeslots of smallest units */
}}}
To facilitate modeling we want to be able to specify subsets. i.e.
{{{
set M subset of E; /* All managers */
set S subset of E; /* All senior employees */
}}}
We also want multiple levels of time descriptors i.e.
Days composed of hours, weeks composed of weeks and month composed of weeks, for example. 
This will allow some constraint to be expressed more simply.

= Roster =
We will allow multiple roster to be defined using the same resources (people). This is an easy and elegant way to handle people working, on call and even vacation time. 
For example
{{{
begin 
set E;
set T;
roster(work)
 ... constraints on work roster ...
roster(onCall)
... constraints on on call roster ...
roster(vacation)
...constraints on vacations ...
end
}}}
= Constraints = 
== Requirements of a roster ==
  * On Monday morning, we need exactly 1 manager, at least 2 senior and at most 3 junior.
  * On Friday evening, we need one employee on call
  * Fred is unavailable to work on Thursdays
  * Code:
{{{
begin
set M; /* managers */
set S; /* senior people */
set J; /* Junior people */
set MM; /* Timeslots of Monday morning */
set FE; /* Timeslots of Friday evening */
set Thursday; /* Timeslots of Thursday */
roster(work)
c(M,MM, exactly(1))
c(S,MM, atLeast(2))
c(J,MM, atMost(3)
roster(onCall)
c(E,FE, exactly(1)
roster(unavailable)
c(Fred,Thursday, exactly(1))   /* syntactic sugar: c(Fred,Thursday) */
end
}}}
  * Semantics:
{{{ 
forall t in MM: sum{e in M} work(e,t) == 1
forall t in MM: sum{e in S} work(e,t) >= 2
forall t in MM: sum{e in J} work(e,t) <= 3
forall t in FE: sum{e in E} onCall(e,t) == 1
forall t in Thursday: sum{e in {Fred}} unavailable(e,t) == 1
}}}
  * The implication of all this is that the employee on call on Friday evening will not be working because the relation (e,t) is tagged with the roster name (work or onCall) and cannot have two names. Same for the unavailable roster.  This seems elegant in the sense that unavailibility is treated exactly as another roster.  Moreover, everything is expressed positively.

  * It seems clear that all requirements of a roster can be expressed in this form
{{{
c(SubsetOfEmployees, SubsetOfTimeslots, Relational(parameter))
}}}

== Requirements of employees ==
There is a symmetric requirement on employees where we express how many hours they should work per week, how many days, etc. Notice that this is the same constraint structure as before but the two objects, Employees and Timeslots have been swapped.
  * All employees work at most 40 hours per week
{{{
c(Week,E,atMost(40))
Semantics:
forall e in Employees: sum{t in Week} work(e,t) <= 40
}}}
  * Managers work at most on 4 days per week  OUPS!  Does Not Work!