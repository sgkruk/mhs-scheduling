Typical scheduling of employees in a retail store

= Introduction =

The paradigmatic retail store has full time, part time employees, managers and worker bees. It has to staff the floor with varying number of people of varying experience.  


= Note on implementation =

We discuss rostering: the scheduling of people.  We decided to view this abstractly, as the establishment of a relation between employees and timeslots.  For example the named couple work(serge, Monday-at-8) means employee Serge works Monday at 8.  Note that there is no duration. We have decomposed the time to schedule into the smallest scheduling unit.  

This does not force an implementation.  The set of all couples name(e,h) form the relation and could be viewed as: 
  * a bipartite graph with employees on one side, timeslots on the other and an edge iff the employee works at that time
  * a multi-level network with employees on one level, months on the second, weeks of the month on the third, days ...
  * a binary matrix indexed by employee and timeslots with a 1 of scheduled, 0 otherwise
  * a record per employee with a list of timeslots when he/she works

The point is that we are not committed, at this point to a specific implementation. We leave the options open but want an abstract concept of what a roster is.  The relation name(e,h) seems to work (for now).

= Sets of resources and timeslots = 

We decided that the data should be separated from the models as much as possible. Two sets, at a minimum, are required to establish the relation. and sets are ordered.
{{{
set E; /* All employees */
set T; /* All timeslots of smallest units */
}}}
To facilitate modeling we want to be able to specify subsets. i.e.
{{{
set M subset of E; /* All managers */
set S subset of E; /* All senior employees */
}}}
We also want multiple levels of time descriptors i.e.
Days composed of hours, weeks composed of days and months composed of weeks, for example. But, sometimes, we want the hours of the week, the days of the month, or even the hours of the month.  There is a question here about what it means to work for a given day of the week.  Assuming that 'hour' is the smallest increment of time, it could mean either
  * work every hour of that day
  * work at least one of the hours of that day.
It is unclear, at this point, which of these is required.  As we model, we should keep this in mind. 

= Roster =
We will allow multiple roster to be defined using the same resources (people). This is an easy and elegant way to handle people working, on call and even vacation time. 
For example
{{{
begin 
set E;  /* Set of employees */
set T;  /* Set of timeslots */
roster(work)
 ... constraints on 'work' roster ...
roster(onCall)
... constraints on 'on call' roster ...
roster(vacation)
...constraints on 'vacations' roster
end
}}}
= Constraints = 
== Requirements of a roster ==
  * On Monday morning, say 0800 to 1200h, we need exactly 1 manager, at least 2 senior and at most 3 junior.
  * On Friday evening, we need one employee on call
  * Fred is unavailable to work on Thursdays
  * Code:
{{{
begin
set M; /* managers */
set S; /* senior people */
set J; /* Junior people */
set MM; /* Timeslots (hours) of Monday morning */
set FE; /* Timeslots (hours) of Friday evening */
set Thursday; /* Timeslots of Thursday */
roster(work)
c(M,MM, exactly(1))
c(S,MM, atLeast(2))
c(J,MM, atMost(3)
roster(onCall)
c(E,FE, exactly(1)
roster(unavailable)
c(Fred,Thursday, exactly(1))   /* syntactic sugar: c(Fred,Thursday) */
end
}}}
  * Semantics:
{{{ 
forall t in MM: sum{e in M} work(e,t) == 1
forall t in MM: sum{e in S} work(e,t) >= 2
forall t in MM: sum{e in J} work(e,t) <= 3
forall t in FE: sum{e in E} onCall(e,t) == 1
forall t in Thursday: sum{e in {Fred}} unavailable(e,t) == 1
}}}
  * The implication of all this is that the employee on call on Friday evening will not be working because the relation (e,t) is tagged with the roster name (work or onCall) and cannot have two names. Same for the unavailable roster.  This seems elegant in the sense that unavailability is treated exactly as another roster.  Moreover, everything is expressed positively. This avoids the questions of how to interpret constraints like "Joe cannot work Friday afternoon" and "Jill can work Friday morning". The problem for these constraints is the universe of discourse.  Does the first one mean that Joe can work 24 hours per day all days by default and we simply exclude Friday afternoon?  Then the Jill constraints seem useless.  Maybe the Jill constraint implies that the default is that no employee can work unless his availability are stated. I can imagine that both defaults make sense in some setting. We better decide to make everything explicitly positive. We could add syntactic sugar to the modeling language if need be later.

  * It seems clear that all the above requirements of a roster can be expressed in this form
{{{
c(SubsetOfEmployees, SubsetOfTimeslots, Relational(parameter))
}}}


== Requirements of employees ==
There is a symmetric requirement on employees where we express how many hours they should work per week, how many days, etc. Notice that this is the same constraint structure as before but the two objects, Employees and Timeslots have been swapped.
  * All employees work at most 40 hours per week
{{{
c(HoursOfWeek,E,atMost(40))
Semantics:
forall e in Employees: sum{t in HoursOfWeek} work(e,t) <= 40
}}}
  * Managers work on at most on 4 days per week.
{{{
c(DaysOfWeek,M,AtMost(4))
Semantics:
forall e in Managers: sum{t in DaysOfWeek} work(e,t) <= 4
}}}

Here is an instance where working on day d clearly should not mean 'working all hours' of day d, but rather 'working any number of hours of day d'.  Maybe the constraints should be different: instead of 'atMost', it could be 'onAtMost'.  Not sure I like adding a constraint.  It would be better if we infered the meaning. 
