Typical scheduling of employees in a retail store

= Introduction =

The paradigmatic retail store has full time, part time employees, managers and worker bees. It has to staff the floor with varying number of people of varying experience.  


= Note on implementation =

We discuss rostering: the scheduling of people.  We decided to view this abstractly, as the establishment of a relation between employees and timeslots.  For example the named couple work(serge, Monday-at-8) means employee Serge works Monday at 8.  Note that there is no duration. We have decomposed the time to schedule into the smallest scheduling unit.  

This does not force an implementation.  The set of all couples name(e,h) form the relation and could be viewed as: 
  * a bipartite graph with employees on one side, timeslots on the other and an edge iff the employee works at that time
  * a multi-level network with employees on one level, months on the second, weeks of the month on the third, days ...
  * a binary matrix indexed by employee and timeslots with a 1 of scheduled, 0 otherwise
  * a record per employee with a list of timeslots when he/she works

The point is that we are not committed, at this point to a specific implementation. We leave the options open but want an abstract concept of what a roster is.  The relation name(e,h) seems to work (for now).

= Sets of resources and timeslots = 

We decided that the data should be separated from the models as much as possible. Two sets, at a minimum, are required to establish the relation. and sets are ordered.
{{{
set E; /* All employees */
set T; /* All timeslots of smallest units */
}}}
To facilitate modeling we want to be able to specify subsets. i.e.
{{{
set M subset of E; /* All managers */
set S subset of E; /* All senior employees */
}}}
We also want multiple levels of time descriptors i.e.
Days composed of hours, weeks composed of days and months composed of weeks, for example. But, sometimes, we want the hours of the week, the days of the month, or even the hours of the month.  There is a question here about what it means to work for a given day of the week.  Assuming that 'hour' is the smallest increment of time, it could mean either
  * work every hour of that day
  * work at least one of the hours of that day.
It is unclear, at this point, which of these is required.  As we model, we should keep this in mind. 

= Two separate models = 
There are really two sets of constraints, what I will call the Cover Constraints and the Resource Constraints.  The first set if the type supplied by data analysis, simulation or even some OR model of the requirements of the shop (need 5 people on the floor at this time). The second set of constraints described what resources can and cannot do (by law, physical limitations, union rules etc...)  

We should keep these two sets separate since it may be very useful to have the first set generated by another model.  Both sets of constraints are tied together in a roster.
   
= Roster =
We will allow multiple roster to be defined using the same resources (people). This is an easy and elegant way to handle people working, on call and even vacation time. 
For example
{{{
begin 
set E;  /* Set of employees */
set T;  /* Set of timeslots */
roster(work)
 ... cover constraints on 'work' roster ...
roster(onCall)
... cover constraints on 'on call' roster ...
roster(vacation)
...cover constraints on 'vacations' roster
resources
... constraints on the resources available for all the above rosters 
end
}}}
= Constraints = 
== Requirements of a roster (Cover Constraints) ==
  * On Monday morning, say 0800 to 1200h, we need exactly 1 manager, at least 2 senior and at most 3 junior.
  * On Friday evening, we need one employee on call
  * Code:
{{{
begin
set Managers := {Serge, Tom, Mark}; /* managers */
set Seniors := {S1, S2, S3}; /* senior people */
set Juniors := {J1, J2, J3, J4, J4}; /* Junior people */
set HoursOfMondayMorning:= {M8,M9,...,M12}; /* Timeslots (hours) of Monday morning */
set Monday := {HoursOfMondayMorning, HoursOfMondayAfternoon, HoursOfMondayEvening};
set HoursOfFridayEvening:={F18,F19,F20,F21}; /* Timeslots (hours) of Friday evening */
set HoursOfThursday := {T8, T9, ..., T21}; /* Timeslots of Thursday */
set HoursOfWeek := {M8, M9, ..., S20, S20}; /* All hours of the week */
set DaysOfWeek := {Monday, ..., Saturday};  /* Set of sets (of sets) */
begin{rosters}
roster(work)
  cover(HoursOfMondayMorning, exactly(1), Managers)
  cover(HoursOfMondayMorning, atLeast(2), Seniors)
  cover(HoursOfMondayMorning, atMost(3), Juniors)
roster(onCall)
  cover(HoursOfFridayEvening, exactly(1), Employee)
end{rosters}
begin{resources}
... see later ...
end{resources}
end
}}}
  * Semantics:
{{{ 
forall t in HoursOfMondayMorning: sum{e in Managers} work(e,t) == 1
forall t in HoursOfMondayMorning: sum{e in Seniors} work(e,t) >= 2
forall t in HoursOfMondayMorning: sum{e in Juniors} work(e,t) <= 3
forall t in HoursOfFridayEvening: sum{e in Employees} onCall(e,t) == 1
}}}
  * The implication of all this is that the employee on call on Friday evening will not be working because the relation (e,t) is tagged with the roster name (work or onCall) and cannot have two names. Same for the unavailable roster.  This seems elegant in the sense that unavailability is treated exactly as another roster.  Moreover, everything is expressed positively. This avoids the questions of how to interpret constraints like "Joe cannot work Friday afternoon" and "Jill can work Friday morning". The problem for these constraints is the universe of discourse.  Does the first one mean that Joe can work 24 hours per day all days by default and we simply exclude Friday afternoon?  Then the Jill constraints seem useless.  Maybe the Jill constraint implies that the default is that no employee can work unless his availability are stated. I can imagine that both defaults make sense in some setting. We better decide to make everything explicitly positive. We could add syntactic sugar to the modeling language if need be later.

  * It seems clear that all cover requirements of a roster can be expressed in this form
{{{
  cover(SubsetOfTimeslots, Relational(parameter), SubsetsOfEmployees)
}}}


== Requirements of employees (Resource Constraints) ==
There is almost (but not exactly) a symmetric requirement on employees where we express how many hours they should work per week, how many days, etc. 

  * All employees work at most 40 hours per week
  * Managers work on at most on 4 days per week.
  * Fred cannot work on Thursday (he can work every other day)
  * Mary must work on Tuesday
  * Juniors must work on at least 2 days per week and at most 5
  * Seniors work on contiguous days (at least 3)
{{{
begin{resources}
  resource(Employees, atMost(40), HoursOfWeek)
  resource(Managers, atMost(4), DaysOfWeek)
  resource({Fred}, atMost(0), HoursOfThursday)
  resource({Mary}, atLeast(1), HoursOfTuesday)
  resource(Employees, atLeast(3), DaysOfWeek)
  resource(Juniors, atMost(5), DaysOfWeek)
  resource(Seniors, regex(N*YYY*N*), DaysOfWeek)
end{resources}
}}}
From the resource point of view 'working on day d' clearly should not mean 'working all hours' of day d, but rather 'working any number of hours of day d'.  This is implicit in the constraints because the set DaysOfWeek is a set of sets.  Every constraints on a set of sets implies that if any of the subset elements are covered, the superset is deemed covered.  

Maybe we need another constraints onAtMost(n) instead of atMost(n).  Not sure yet.



 